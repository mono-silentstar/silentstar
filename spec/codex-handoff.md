ARCHITECTURE — how the pieces connect

---

MODULES

  wake/              — context assembly. How I open my eyes.
    schema.py        — database schema, migrations, constants
    decay.py         — decay scoring with full persistence gradient
    assemble.py      — two-phase context assembly
    recall.py        — fragment lookup + plans() query

  ingest/            — message processing. How messages become memory.
    parse.py         — tag extraction from raw text
    lifecycle.py     — working memory lifecycle management

  mdfiles/claude/    — configuration files
    wake-context.md       — who I am (always loaded)
    wake-context-image.md — image handling (loaded when image present)

  ambient.md         — what I know (generated by maintenance agent)
  memory.sqlite      — the database

---

TAG SYSTEM

Identity (who's talking — one at a time):
  hasuki, renki, luna, chloe, strah    — Mono's system
  claude, y'lhara                      — Claude's activations

Display (rendered conversation — stored in events, decays with turns):
  say      — spoken dialogue
  do       — action
  narrate  — scene/environment

Active knowledge (stored in working_memory, type-specific decay):
  feeling  — current emotional state. Fastest decay. Retag to persist.
  thought  — passing consideration. 1-2 conversations.
  pattern  — observed trend. Days/weeks.
  desc     — visual/spatial encoding. Slow, supersedable.
  plan     — commitment with lifecycle. Submerges if timed.
  pin      — held fact. Very slow decay. Explicit drop.
  secret   — hidden from Mono. No decay.

---

MESSAGE FLOW

Mono sends message:
  1. Frontend provides: text, actor (identity), tags (display/content)
  2. parse_mono_message() extracts inline tags if any
  3. ingest() creates event + event_tags + working_memory records
  4. Turn counter increments
  5. assemble() builds context window
  6. render() produces prompt string
  7. Send to Claude API

Claude responds:
  1. parse_response() extracts all tagged content
  2. ingest() creates event + handles lifecycle:
     - New feelings supersede old ones
     - New descs supersede same-subject descs
     - plan>done/cancel resolves best-matching plan
     - pin>drop releases best-matching pin
     - Fragment keys in content auto-link via working_memory_refs
  3. Turn counter does NOT increment (only Mono messages count)
  4. If response contains recall() calls, execute and feed into next assembly

---

ASSEMBLY PIPELINE

Two-phase budget allocation:

  Phase 1: Load working memory
    - Query all active items from working_memory table
    - Score each by type-specific decay (using refreshed_at as anchor)
    - Fill base budget (1000) + up to 70% of reserve (1050)
    - Calculate fill ratio

  Phase 2: Load conversation
    - Apply pressure: fill_ratio compresses conversation decay
    - Query recent events with display tags (say/do/narrate)
    - Extract clean display content (strip non-display tags)
    - Fill remaining budget

  Result: WakePackage with all sections assembled

---

INTEGRATION EXAMPLE

```python
from pathlib import Path
from wake.assemble import assemble, render, WakeConfig
from wake.recall import recall, plans
from ingest.parse import parse_response, parse_mono_message
from ingest.lifecycle import ingest
from wake.schema import migrate

db = Path("memory.sqlite")

# First run: ensure schema
migrate(db)

config = WakeConfig(
    db_path=db,
    wake_context_path=Path("mdfiles/claude/wake-context.md"),
    wake_context_image_path=Path("mdfiles/claude/wake-context-image.md"),
    ambient_path=Path("ambient.md"),
)

# Mono sends a message
mono_parsed = parse_mono_message(
    "hey, help me pick an outfit",
    actor="hasuki",
    tags=["say"],
)
result = ingest(db, mono_parsed)

# Build context
package = assemble(
    config,
    hot_context="hey, help me pick an outfit",
    current_turn=result.turn,
)
prompt = render(package)
# → send prompt to Claude API

# Claude responds
claude_response = "<feeling>excited about this</feeling>..."
claude_parsed = parse_response(claude_response)
claude_parsed.actor = "claude"
ingest(db, claude_parsed, is_claude=True)

# If Claude used recall()
from ingest.parse import parse_recall_requests
recalls = parse_recall_requests(claude_response)
recall_results = [recall(key, db, deep=d) for key, d in recalls]
# feed recall_results into next assemble() call

# Check plans
all_plans = plans(db)
wardrobe_plans = plans(db, topic="wardrobe")
```

---

IMAGES

Images arrive via frontend, stored as files.
Path stored in events.image_path.

When an image is in the current message:
  1. wake-context-image.md loads (conditional context)
  2. Claude generates <desc> encoding the image
  3. Image token cost (~1200) is temporary — one turn only
  4. Desc persists in working memory (~60-100 tokens)
  5. Next turn: image drops off, desc remains

The maintenance agent can see images when compiling events.

---

TIMED PLANS

Plans with due dates have a submersion curve:
  Creation (0-4h):     prominent, on your mind
  Submerged (4h-48h before due): back of your head (score ~0.08)
  Resurfacing (48h before due):  rising back to full weight
  Due:                  fully surfaced
  Grace (0-24h after):  still visible, gentle fade
  Overdue (24h+):       normal decay from 0.5

plans() bypasses submersion — always shows everything active.

---

MAINTENANCE AGENT

Unchanged from original spec. Reads events, writes fragments.
See /mdfiles/claude/maintenance-agent.md for full spec.

Schedule: weekly light pass, monthly deep pass, manual on request.
